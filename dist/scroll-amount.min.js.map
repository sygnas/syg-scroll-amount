{"version":3,"file":"scroll-amount.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\n * Add scrolling state(top / not-top / bottom / not-bottom)\n *\n * @author   Hiroshi Fukuda <info.sygnas@gmail.com>\n * @license  MIT\n */\n\nimport { TOption, TTopOrBottom } from \"./types\";\n\n\n///////////////////////////////////////\n\n\n// 状態を付与するためのdata属性\nconst ATTR_NAME: string = \"data-scroll-amount\";\n\n// 状態の名前\nconst ATTR_TOP: string = \"top\";\nconst ATTR_BOTTOM: string = \"bottom\";\nconst ATTR_NOT_TOP: string = \"not-top\";\nconst ATTR_NOT_BOTTOM: string = \"not-bottom\";\nconst ATTR_POSITION: string = \"data-position\";\n\n// 監視用エレメントのデフォルトstyle\nconst COMMON_STYLE: object = {\n  position: \"absolute\",\n  left: \"0\",\n};\n\n// IntersectionObserverの設定\nconst OBSERVER_OPT: IntersectionObserverInit = {\n  root: null,\n  rootMargin: \"0px\",\n  threshold: 0,\n};\n\n///////////////////////////////////////\nclass SygScrollAmount {\n  private opt: TOption;\n  private targets;\n  private isTop: boolean;\n  private isBottom: boolean;\n  private lastState: string;\n  // private observers: IntersectionObserver[];\n\n  /**\n   * コンストラクタ\n   * @param target string 状態を付与する対象エレメントのセレクタ文字列\n   */\n  constructor(target: string, options: TOption = {}) {\n    const defaults: TOption = {\n      // 最上部のオフセット\n      offsetTop: \"70px\",\n      // 最下部のオフセット\n      offsetBottom: \"70px\",\n      // 最上部にスクロールした時に実行\n      onTop() {},\n      // 最上部から離れた時に実行\n      onNotTop() {},\n      // 最下部にスクロールした時に実行\n      onBottom() {},\n      // 最下部から離れた時に実行\n      onNotBottom() {},\n    };\n\n    // 与えられた設定を適用\n    this.opt = Object.assign(defaults, options);\n    // 状態付与の対象\n    this.targets = document.querySelectorAll<HTMLElement>(target);\n    // 一番上にスクロールした\n    this.isTop = false;\n    // 一番下にスクロールした\n    this.isBottom = false;\n    // 最後の状態\n    this.lastState = '';\n\n    this.start();\n  }\n\n  /**\n   * 監視用エレメント作成して監視開始\n   */\n  createObserveElement(position: TTopOrBottom): HTMLDivElement {\n    const element: HTMLDivElement = document.createElement(\"div\");\n\n    Object.assign(element.style, COMMON_STYLE);\n    element.style.height = this.opt.offsetTop as string;\n    element.setAttribute(ATTR_POSITION, position);\n\n    if (position === \"top\") {\n      element.style.top = \"0\";\n    } else {\n      element.style.bottom = \"0\";\n    }\n    // ページ最下部に追加\n    document.body.appendChild(element);\n    return element;\n  }\n\n  /**\n   * スクロール検知処理を開始\n   */\n  private start() {\n    // <body> に position 設定\n    document.body.style.position = \"relative\";\n\n    // IntersectionObserverを作成して監視開始\n    const observer: IntersectionObserver = new IntersectionObserver(\n      this.observerCallback.bind(this),\n      OBSERVER_OPT\n    );\n\n    // 監視用エレメント作成\n    observer.observe(this.createObserveElement(\"top\"));\n    observer.observe(this.createObserveElement(\"bottom\"));\n  }\n\n  /**\n   * スクロール処理\n   * IntersectionObserver に反応した <div> が top/bottom どちらかで判定する\n   */\n  private observerCallback( entries: IntersectionObserverEntry[]): void {\n\n    entries.forEach((entry) => {\n      const position: TTopOrBottom = entry.target.getAttribute(\n        ATTR_POSITION\n      ) as TTopOrBottom;\n\n      if (position === \"top\") {\n        this.isTop = entry.isIntersecting;\n      } else {\n        this.isBottom = entry.isIntersecting;\n      }\n    });\n\n    // 属性を付与\n    this.setAttribute();\n  }\n\n  /**\n   * 属性を付与\n   */\n  private setAttribute(): void {\n    const state: string = [\n      this.isTop ? ATTR_TOP : ATTR_NOT_TOP,\n      this.isBottom ? ATTR_BOTTOM : ATTR_NOT_BOTTOM,\n    ].join(' ');\n\n    // 結果を data属性に反映する\n    // 前回と同じなら反映しない\n    if (state !== this.lastState) {\n      this.lastState= state;\n\n      this.targets.forEach((target: HTMLElement) => {\n        target.setAttribute(ATTR_NAME, state);\n      });\n\n      // オプション関数を実行\n      if(this.isTop && this.opt.onTop){\n        this.opt.onTop();\n      }else if(this.opt.onNotTop){\n        this.opt.onNotTop();\n      }\n\n      if(this.isBottom && this.opt.onBottom){\n        this.opt.onBottom();\n      }else if(this.opt.onNotBottom){\n        this.opt.onNotBottom();\n      }\n    }\n  }\n}\n\n\nexport default SygScrollAmount;\n"],"names":["ATTR_POSITION","COMMON_STYLE","position","left","OBSERVER_OPT","root","rootMargin","threshold","SygScrollAmount","target","options","defaults","offsetTop","offsetBottom","onTop","onNotTop","onBottom","onNotBottom","opt","Object","assign","targets","document","querySelectorAll","isTop","isBottom","lastState","start","element","createElement","style","height","this","setAttribute","top","bottom","body","appendChild","observer","IntersectionObserver","observerCallback","bind","observe","createObserveElement","entries","forEach","entry","getAttribute","_this","isIntersecting","state","join"],"mappings":";;;;;;KAcA,IAOMA,EAAwB,gBAGxBC,EAAuB,CAC3BC,SAAU,WACVC,KAAM,KAIFC,EAAyC,CAC7CC,KAAM,KACNC,WAAY,MACZC,UAAW,GAIPC,wBAYQC,OAAgBC,yDAAmB,2IACvCC,EAAoB,CAExBC,UAAW,OAEXC,aAAc,OAEdC,mBAEAC,sBAEAC,sBAEAC,+BAIGC,IAAMC,OAAOC,OAAOT,EAAUD,QAE9BW,QAAUC,SAASC,iBAA8Bd,QAEjDe,OAAQ,OAERC,UAAW,OAEXC,UAAY,QAEZC,mEAMP,SAAqBzB,OACb0B,EAA0BN,SAASO,cAAc,cAEvDV,OAAOC,OAAOQ,EAAQE,MAAO7B,GAC7B2B,EAAQE,MAAMC,OAASC,KAAKd,IAAIN,UAChCgB,EAAQK,aAAajC,EAAeE,GAEnB,QAAbA,EACF0B,EAAQE,MAAMI,IAAM,IAEpBN,EAAQE,MAAMK,OAAS,IAGzBb,SAASc,KAAKC,YAAYT,GACnBA,uBAMD,WAENN,SAASc,KAAKN,MAAM5B,SAAW,eAGzBoC,EAAiC,IAAIC,qBACzCP,KAAKQ,iBAAiBC,KAAKT,MAC3B5B,GAIFkC,EAASI,QAAQV,KAAKW,qBAAqB,QAC3CL,EAASI,QAAQV,KAAKW,qBAAqB,2CAOrC,SAAkBC,cAExBA,EAAQC,SAAQ,SAACC,GAKE,QAJcA,EAAMrC,OAAOsC,aAC1C/C,GAIAgD,EAAKxB,MAAQsB,EAAMG,eAEnBD,EAAKvB,SAAWqB,EAAMG,uBAKrBhB,2CAMC,eACAiB,EAAgB,CACpBlB,KAAKR,MA/Hc,MAEI,UA8HvBQ,KAAKP,SA/HiB,SAEI,cA8H1B0B,KAAK,KAIHD,IAAUlB,KAAKN,iBACZA,UAAWwB,OAEX7B,QAAQwB,SAAQ,SAACpC,GACpBA,EAAOwB,aA5IW,qBA4IaiB,MAI9BlB,KAAKR,OAASQ,KAAKd,IAAIJ,WACnBI,IAAIJ,QACFkB,KAAKd,IAAIH,eACXG,IAAIH,WAGRiB,KAAKP,UAAYO,KAAKd,IAAIF,cACtBE,IAAIF,WACFgB,KAAKd,IAAID,kBACXC,IAAID"}